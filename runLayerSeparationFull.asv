% code directory
clear all;
addpath(genpath('\\phhydra\data-new\phkinnerets\Lab\CODE\Hydra')); %Path for all code
%% Parameters for creating cost image
% Calibration for z and xy of image stacks:
z_scale = 3; % um/pixel
% xy_scale = 0.99; % um/pixel for 10x lens with 1.6x magnification
xy_scale = 1.28; % um/pixel for 10x lens with 1x magnification
% xy_scale = 0.65; % um/pixel for 20x lens with 1x magnification
% xy_scale = 0.57 % um/pixel for lightsheet
outputZScale = 1; % Default: 1, can change if you want to downsample.
use_CLAHE = 1;  % Default: 1, set to 0 if don't want to use CLAHE to normalise gradients.
norm_window = 4; % Default: 4. norm_window*blocksigma is the length scale for normalisation of gradient using CLAHE.
% Decreasing can sometimes help prevent jumps between surfaces.
saveDiffused = 0; % Set to one to save diffused images, and to zero to not save.
numLayers = 2 ; % Set to 2 for two layers (default), and set to 1 for single layer.

%% Parameters for layer separation
rescalexy = 0.5; % Rescaling when running min cost algorithm. 0.5 for xy significantly speeds calculation, and also helps limit the maximum slope of the detected surface (see maxdz).
rescalez = 1; % Rescaling when running min cost algorithm. Not recommended for z direction so performance is not compromised.
display = 0; % Set to 1 to display results in ImageJ, and 0 to prevent display. Not sure if this is relevant when running from command line. 
min = 15; % Minimum distance in um between surfaces to use for detection. 
interval = 30; % Range for distance between layeres for detection in um (so minimum distance will be min, and maximum will be min+interval).

% The following are calculated from the parameters above and typically don't need to be chagned:
maxdz = round((3/z_scale)+0.49); % This is the maximum allowed step in z between neighbouring pixels in xy (after rescaling according to above). This was found to be optimal.
min=(round(min*rescalez/z_scale)); % Convert minimum distance from um to pixels
max = min+(round(interval*rescalez/z_scale)); % Convert minimum distance from um to pixels
            

%% Parameters for surface projections
offset = [-5:1]; % Range of offest from the detected surface to use for projection images. Test a few and choose what range you need.
CLAHE = 0; % Set to 1 if want to normalise intensity in images using CLAHE. DEFAULT IS 0.
ZLimits = {[],1}; % If there is a disturbing feature in the stack that you would like to leave out of projections, set a limit to what slices can be used from the z-stack.
% Leave empty if you don't want to specify any limits.

%% Define directories of original images to run over folders and create cost images (original images should be 3D image stacks saved as separate timepoints).

topMainDir='\\phhydra\TempData\SD\Yonit\2020\2020_10\2020_10_29\TIFF Files\'; % main folder of original files for layer separation
mainDirList= { ... % enter in the following line all the  movie dirs for cost calculation.
    
'Pos_15\C0\',...

};
for i=1:length(mainDirList),mainInDirList{i}=[topMainDir,mainDirList{i}];end

topAnalysisDir='\\PHHYDRA\phhydraB\Analysis\users\Yonit\Movie_Analysis\Labeled_cells\'; % main folder for layer separation results
mainAnalysisDirList= { ... % enter in the following line all the output dirs for cost calculation.
    
'2020_10_29_pos15\', ...

};
for i=1:length(mainAnalysisDirList),AnalysisDirList{i}=[topAnalysisDir,mainAnalysisDirList{i}];end

%% Run over all folders in mainDirList and create cost images, which are saved in matching subfolders in topAnalysisDir.
for i=1:length(mainDirList)
    analysisDir = [AnalysisDirList{i},'\Layer_Separation\'];
    inputDir = mainInDirList{i}
    maskDir = [AnalysisDirList{i},'\Display\Masks\'];
    outputDir = [analysisDir,'\Output'];
    
    % Directories for saving diffused and cost images.
    dirGradient=[analysisDir,'\Gradient'];
    dirDiffused=[analysisDir,'\Diffused'];
    
    if numLayers == 1
        dirGradient=[analysisDir,'\Gradient_1Layer'];
    end
    
    % Directories for height maps and surface projections
    heightDir0=[analysisDir,'\Output\Height_Maps_0\'];
    matlabProjDir0=[AnalysisDirList{j},'\Layer_Separation\Output\Matlab_Projections_0\'];
    smoothHeightDir0 = [AnalysisDirList{j},'\Layer_Separation\Output\Smooth_Height_Maps_0\'];
    fvDir0 = [AnalysisDirList{j},'\Layer_Separation\Output\FV_0\'];
    
    
    % make all the needed directories
    mkdir(analysisDir);
    cd(analysisDir);
    mkdir(dirGradient);
    mkdir(outputDir);
    mkdir(heightDir0);
    mkdir(fvDir0);
    mkdir(matlabProjDir0);
    mkdir(smoothHeightDir0);
    if saveDiffused ==1
        mkdir(dirDiffused);
    end
    
    % define and make directories for second layer:
    
    if numLayers == 2
        heightDir1=[analysisDir,'\Output\Height_Maps_1\'];
        matlabProjDir1=[AnalysisDirList{j},'\Layer_Separation\Output\Matlab_Projections_1\'];
        smoothHeightDir1 = [AnalysisDirList{j},'\Layer_Separation\Output\Smooth_Height_Maps_1\'];
        fvDir1 = [AnalysisDirList{j},'\Layer_Separation\Output\FV_1\'];
        mkdir(heightDir1);
        mkdir(fvDir1);
        mkdir(matlabProjDir1);
        mkdir(smoothHeightDir1);
    end
    
    save('CostParameters', 'z_scale','xy_scale','use_CLAHE','norm_window','numLayers') % saves the variables including the analysis parameters used
    
    cd (maskDir);
    tpoints = dir('*tif*');
    % tpoints = dir('*C0*.tif*');
    
    parfor j = 1:length(tpoints)
        name_end = find(tpoints(j).name == '.');
        thisFileImName = [tpoints(j).name(1:(name_end-1))]
        if numLayers == 2
            CreateCost_with_CLAHE(thisFileImName, inputDir, analysisDir,maskDir, z_scale,xy_scale,outputZScale, use_CLAHE, norm_window, saveDiffused);
            % Here run the macro "Layer_Separation_Frame" with the
            % following input parameters:
            
%           *  thisFileImName - name of file without .tiff ending.
%           *  inputDir - input directory of original image files
%           *  dirGradient - input directory of cost (gradient) files
%           *  rescalexy
%           *  rescalez
%           *  maxdz
%           *  max
%           *  min
%           *  heightDir0
%           *  heightDir1

        
            
            % NOW RUN FUNCTION TO CREATE SURFACE PROJECTIONS:
            % Run on first layer
            smoothHM = smoothHeightMap(thisFileImName, maskDir, heightDir0,smoothHeightDir0,fvDir0, xy_scale, z_scale);
            makeFrameProjection_smoothedHM(thisFileImName, inputDir, matlabProjDir0,xy_scale, offset,smoothHM,CLAHE, zLimits );
            % Run on second layer
            smoothHM = smoothHeightMap(thisFileImName, maskDir, heightDir1,smoothHeightDir1,fvDir1, xy_scale, z_scale);
            makeFrameProjection_smoothedHM(thisFileImName, inputDir, matlabProjDir1,xy_scale, offset,smoothHM,CLAHE, zLimits );
            
        elseif numLayers == 1
            CreateCost_Single_Layer(thisFileImName, inputDir, analysisDir,maskDir, z_scale,xy_scale,outputZScale, use_CLAHE, norm_window, saveDiffused);
           % Here run the macro "Layer_Separation_Frame_Single_Layer" with the
            % following input parameters:
                           
            %  *  thisFileImName - name of file without .tiff ending.
            %  *  inputDir - input directory of original image files
            %  *  dirGradient - input directory of cost (gradient) files
            %  *  rescalexy
            %  *  rescalez
            %  *  maxdz
            %  *  max
            %  *  min
            %  *  heightDir0

            % NOW RUN FUNCTION TO CREATE SURFACE PROJECTIONS:
            % Run on first layer
            smoothHM = smoothHeightMap(thisFileImName, maskDir, heightDir0,smoothHeightDir0,fvDir0, xy_scale, z_scale);
            makeFrameProjection_smoothedHM(thisFileImName, inputDir, matlabProjDir0,xy_scale, offset,smoothHM,CLAHE, zLimits );
            
        end
        
    end
    
end





